---
pdf_document:
  highlight: zenburn
author: 'Autor: Ernest Albets Moreno'
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
    highlight: zenburn
header-includes:
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhf{} 
  - \rfoot{\thepage}  # Número de página en el pie de página derecho
  - \usepackage{booktabs}  # Paquete para mejorar las tablas
  - \usepackage{listings}
  - \lstset{breaklines=true, breakatwhitespace=true, basicstyle=\ttfamily\small}
number_sections: yes
theme: cosmo
toc: yes
toc_depth: 2
word_document: default
title: 'Treball Final de Màster: Cerca dels gens involucrats en el grau histològic de tumors de mama'
editor_options:
  markdown: null
  wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Establim la ruta del directori de treball
setwd("C:/Users/ernea/OneDrive/Escritorio/UOC - Data Science/SEMESTRE 5 TFM/src/Treball_Final_Master/")

# Ruta directori dades d'entrada
ruta_input <- "data/input/"
# Ruta directori de sortida
ruta_output <- "data/output/"

# Packages:
if (!requireNamespace("rmarkdown", quietly = TRUE)) install.packages("rmarkdown")
if (!requireNamespace("dplyr", quietly = TRUE)) install.packages("dplyr")
if (!requireNamespace("ggplot2", quietly = TRUE)) install.packages("ggplot2")
if (!requireNamespace("knitr", quietly = TRUE)) install.packages("knitr")
if (!requireNamespace("kableExtra", quietly = TRUE)) install.packages("kableExtra")
if (!requireNamespace("progress")) install.packages("progress")
if (!requireNamespace("glmnet")) install.packages("glmnet")
if (!requireNamespace("lightgbm")) install.packages("lightgbm")
if (!requireNamespace("xgboost")) install.packages("xgboost")
if (!requireNamespace("randomForest")) install.packages("randomForest")
if (!requireNamespace("progress")) install.packages("progress")
if (!requireNamespace("caret")) install.packages("caret")

# Llibreries:
library(dplyr)
library(ggplot2)
library(knitr)
library(kableExtra)
library(progress)
library(glmnet)
library(xgboost)
library(lightgbm)
library(reshape2)
library(randomForest)
library(caret)
```

# Introducció
  
  En aquest treball s'apliquen un conjunt de **tècniques de regressió de machine-learning de tipus supervisat** diferents sobre un conjunt de dades de pacients de tumors de mama on figuren com a característiques:
  
  - Conjunt d'**expressions genètiques** dels **tumors de mama** de cada una de les pacients extretes amb la tècnica de microarrays (variables independents de tipus quantitatives contínues)
  
  - **Grau histològic** del tumor (variable objectiu, de tipus categòric ordinal de 3 classes)

Es tracta, per tant, d'un conjunt de dades supervisat.

Les tècniques d'aprenentatge automàtic que s'apliquen per a obtenir les importàncies (ja siguin positives, com a factors de risc, o negatives, com a protectors) dels conjunts de gens en cada un dels diferents graus histològics són les següents:


- TÈCNIQUES BASADES EN ABRES DE DECISIÓ I/O DESCENS DE GRADIENT:

  * **Random Forest**
  * **XGBoost** (arbres de decisió i descens de gradient)
  * **LightGBM** (arbres de decisió i descens de gradient, més veloç que XGBoost)

- TÈCNIQUES BASADES EN REGULARITZACIÓ:

  * **Ridge Regression o L2**
  * **Lasso Regression o L1**
  * **Elastic Net** (combinació de les dues anteriors L1 i L2)

# Objectiu

  Detectar quins són els gens o conjunts de gens candidats a tenir **més rellevància** en relació a cada un dels diferents graus histològics dels tumors de mama. En alguns casos la importància dels gens pot ser de caràcter positiu i actuar com a elements protectors, o pel contrari, de caràcter negatiu i actuar com a factors de risc.
  
  Establir rànkings i comparatives dels resultats en cada una de les tècniques de machine-learning supervisat aplicades així com gràfiques que n'il·lustrin els resultats. 
  
# 0. Càrrega de funcions genèriques 

En primer lloc, es carreguen una sèrie de funcions de caràcter general que seran utilitzades i accedides per a diversos processos de les diferents seccions del present treball i que eviten la redundància de codi i el contingut excessiu.

```{r}
## FUNCIONS GENÈRIQUES

## Funció de càrrega, processament i unió amb les dades gèniques de la plataforma utilitzada per extracció de microarrays
# 1. Carrega i llegeix el contingut de la taula de la ruta especificada
# 2. Captura i reanomena la variable que ens interessa, l'odentificador i el símbol del gen: GENE_SYMBOL
# 3. Uneix la matriu d'expressions gèniques passada per paràmetre amb el seus GENE_SYMBOL que figuren en la taula de la plataforma emprant l'ID_REF com a nexe.
process_platform_table <- function(origin_path, platform_name, gene_expression_matrix) {
  
  # filePath
  filePath <- paste0(origin_path, platform_name)
  # Read lines
  paltform_file <- readLines(filePath)
  paltform_file <- read.table(text = paltform_file, header = TRUE, sep = "\t", quote = "\"")
  
  # Selecció només de la informació de l'ID i el Gene.Symbol
  gene_info_selected <- paltform_file[, c("ID", "Gene.Symbol")]
  # Substituir '///' per ', ' en la columna Gene.Symbol, pels que tenen més d'un símbol
  gene_info_selected$Gene.Symbol <- gsub("///", ", ", gene_info_selected$Gene.Symbol)
  # Reanomenem GEN_SYMBOL
  colnames(gene_info_selected)[colnames(gene_info_selected) == "Gene.Symbol"] <- "GENE_SYMBOL"
  
  # Unió de les dues taules emprant la columna ID_REF de matriu_expressio_genetica_4 y ID de gene_info_selected
  matriu_genetica_final <- merge(gene_expression_matrix, gene_info_selected[, c("ID", "GENE_SYMBOL")],
                          by.x = "ID_REF", by.y = "ID", all.x = TRUE)
  
  
  # Reorganitzar les columnes per a que ID i GENE_SYMBOL apareixin primer
  matriu_genetica_final <- matriu_genetica_final[, c("ID_REF", "GENE_SYMBOL", setdiff(names(matriu_genetica_final), c("ID_REF", "GENE_SYMBOL")))]
  
  return(matriu_genetica_final)

}

## Funció de processament i neteja de la matriu final d'expressió genètica unida a les dades de la plataforma
# 1. Comprova si existeixen registres repetits que coincideixen amb el mateix GENE_SYMBOL. En cas afirmatiu:
#  - S'observa si existeixen files l'identificador de les quals no es troba present entre els existents de la plataforma i per tant, no tenen relació. En cas afirmatiu:
#     * Els eliminem
#  - S'agrupen totes les files per GENE_SYMBOL i a les repetides s'assigna el valor de la mitja aritmètica com a valor resultant

process_merged_gene_expression <- function(gene_expression_matrix) {
  
  # Comprovació de repeticions en la columna de GENE_SYMBOL per tal d'aplicar la mitja en cas afirmatiu
  repeated_genes <- gene_expression_matrix %>%
    group_by(GENE_SYMBOL) %>%
    summarise(count = n()) %>%
    filter(count > 1)

  if (nrow(repeated_genes) > 0) {
    cat("S'han trobat símbols de gens repetits en la columna GENE_SYMBOL, procedim a realitzar les mitjanes aritmètiques dels resultats repetits\n")
  
    # Comprovem si existeixen registres sense relació amb l'identificador de la plataforma
    missing_genes <- gene_expression_matrix %>%
      filter(is.na(GENE_SYMBOL) | GENE_SYMBOL == "")
  
    if (nrow(missing_genes) > 0) {
      cat("Tenim", nrow(missing_genes)," registres NO associats a cap identificador de la plataforma que seran eliminats.")
    
    # Eliminació registres no associats a cap identificador de la plataforma
    gene_expression_matrix <- gene_expression_matrix %>%
      filter(!is.na(GENE_SYMBOL) & GENE_SYMBOL != "")
    
      cat("Els registres sense identificador de plataforma s'han eliminat correctament.\n")
    
  }  else {
      cat("Tots els registres estan associats amb un identificador.\n")
  }
  
    # Realitzem l'agrupació per columna GENE_SYMBOL i la mitjana aritmètica dels valors que coincideixen amb el mateix GENE_SYMBOL, d'aquesta manera
    # - Desapareixen els registres amb gene_symbol repetit quedant-ne només un com amb els valors mitjos de tots els coincidents com a resultant
    gene_expression_matrix <- gene_expression_matrix %>%
      group_by(GENE_SYMBOL) %>%       # Agrupem per GENE_SYMBOL
      summarise(across(starts_with("GSM"), ~ round(mean(.x, na.rm = TRUE), 3))) %>%  # Calcula la mitja de les columnes que comencen per "GSM" (geo accession)
      ungroup()
  
  } else {
    cat("No s'han trobat símbols de gens repetits en la columna GENE_SYMBOL.\n")
  }
  
  return(gene_expression_matrix)
  
}

## Funció de bolcatge dels resultats en un fitxer .csv a una ruta destí
write_to_csv <- function(gene_expression_matrix_processed, destination_path, filename) {
  
  # Bolquem els resultats en un fitxer .csv
  ruta_destino <- paste0(destination_path,filename)
  write.csv(gene_expression_matrix_processed, ruta_destino, row.names = FALSE)
  
}


## Funció de normalització
# Realitza la normalització de tots els valors continguts en una matriu de tipus llista @matrix passada per paràmetre. 
# La normalització posa tots els valors en un interval entre 0 i 1 tenint en compte el màxim i el mínim
# Funció per normalitzar una matriu entre 0 i 1
normalize_matrix <- function(matrix_list) {
  # Comprovar que la matriu d'entrada és una llista
  if (!is.list(matrix_list)) {
    stop("L'entrada ha de ser una llista.")
  }
  
  # Aplanar la llista en un sol vector per calcular el mínim i el màxim
  vector_values <- unlist(matrix_list)
  min_val <- min(vector_values, na.rm = TRUE)
  max_val <- max(vector_values, na.rm = TRUE)
  
  # Funció de normalització entre 0 i 1
  normalize_value <- function(x) {
    (x - min_val) / (max_val - min_val)
  }
  
  
  # Aplicar la normalització a cada element de la llista mantenint la seva estructura
  matrix_norm <- lapply(matrix_list, function(sublist) {
    # Normalitzar cada subllista o vector individualment
    sapply(sublist, normalize_value)
  })
  
  # Retornar la matriu normalitzada
  return(matrix_norm)
}


# Funció genèrica que crea un diagrama de barres horitzonals a partir de la llibreria ggplot2 per visualitzar
# el rànking de resultats de les importàncies dels gens en cada una de les tècniques de machine-learning diferents
# aplicades i per a un determinat grau histològic específic
# Paràmetres:
# - data: dades que contenen les importàncies de cada característica (gens) 
# - X: columna de dades en eix X
# - y: columna de dades en eix Y
# - color: color de les barres horitzontals
# - title: títol de la gràfica
# - top_num: nombre d'elements (gens) a visualitzar en les y's
# - xlablel: etiqueta en l'eix 'X'
# - ylabel: etiqueta en l'eix 'Y'
create_horitzontal_barchart_plot <- function(data, X, Y, color, title, top_num, xlabel, ylabel) {
  
  plot <- ggplot(data[1:top_num,], aes(x = reorder(.data[[X]], .data[[Y]]), y = .data[[Y]])) +
    geom_bar(stat = "identity", fill = color) +
    coord_flip() +
    labs(title = title, x = xlabel, y = ylabel) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = "white"), # Fons del gràfic
      plot.background = element_rect(fill = "white", color = "white"),  # Fons del quadre del gràfic
      panel.grid.major = element_line(color = "grey80"),                # Línies de la quadrícula
      panel.grid.minor = element_blank()                                # Línies de quadrícula menors
    )
  
  return(plot)
}


# Funció genèrica que crea un diagrama de punts a partir de la llibreria ggplot2 per visualitzar
# el rànking de resultats de les importàncies dels gens en cada una de les tècniques de machine-learning diferents
# aplicades i per a un determinat grau histològic específic
# Paràmetres:
# - data: dades que contenen les importàncies de cada característica (gens) 
# - X: columna de dades en eix X
# - y: columna de dades en eix Y
# - color: color de les barres horitzontals
# - title: títol de la gràfica
# - top_num: nombre d'elements (gens) a visualitzar en les y's
# - xlablel: etiqueta en l'eix 'X'
# - ylabel: etiqueta en l'eix 'Y'
create_point_chart_plot <- function(data, X, Y, color, title, top_num, xlabel, ylabel) {
  
  plot <- ggplot(data[1:top_num,], aes(x = .data[[Y]], y = reorder(.data[[X]], .data[[Y]]))) +
    geom_point(size = 3, color = color) +
    labs(title = title, x = xlabel, y = ylabel)
  theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = "white"), # Fons del gràfic
      plot.background = element_rect(fill = "white", color = "white"),  # Fons del quadre del gràfic
      panel.grid.major = element_line(color = "grey80"),                # Línies de la quadrícula
      panel.grid.minor = element_blank()                                # Línies de quadrícula menors
    )
  
  return(plot)
}


# Funció genèrica que crea un diagrama de barres horitzonals amb valors positius i/o negatius a partir de la llibreria ggplot2 
# per visualitzar el rànking de resultats de les importàncies dels gens en cada una de les tècniques de machine-learning 
# basades en la regularització i a partir d'un grau histològic específic
# Paràmetres:
# - data: dades que contenen les importàncies de cada característica (gens) 
# - X: columna de dades en eix X
# - y: columna de dades en eix Y
# - z: distinció del signe
# - color1: color de les barres horitzontals amb valors positius
# - color2: color de les barres horitzontals amb valors negatius
# - title: títol de la gràfica
# - subtitle: subtitol
# - top_num: nombre d'elements (gens) a visualitzar en les y's
# - xlablel: etiqueta en l'eix 'X'
# - ylabel: etiqueta en l'eix 'Y'
create_horitzontal_barchart_with_sign_plot <- function(data, X, Y, z, color1, color2, title, subtitle, top_num, xlabel, ylabel) {
  
  plot <- ggplot(data[1:top_num,], aes(x = reorder(.data[[X]], .data[[Y]]), y = .data[[Y]], fill= .data[[z]])) +
    geom_bar(stat = "identity") +
    coord_flip() +
    scale_fill_manual(values = c("Positiu (Risc)" = color1, "Negatiu (Protecció)" = color2)) +
    labs(
      title = title,
      subtitle = subtitle,
      x = xlabel,
      y = ylabel
    ) +
    theme_minimal() +
    theme(
      panel.background = element_rect(fill = "white", color = "white"), # Fons del gràfic
      plot.background = element_rect(fill = "white", color = "white"),  # Fons del quadre del gràfic
      panel.grid.major = element_line(color = "grey80"),                # Línies de la quadrícula
      panel.grid.minor = element_blank(),                               # Línies de quadrícula menors
      legend.position = "top"                                           # Llegenda a la part superior
    )
  
  return(plot)
}

```

# 1. Càrrega i processament dels conjunts de dades

Originalment es tenen **dos conjunts de dades** diferents amb informació extreta de diferents pacients amb tumors de mama.

- **Conjunt de dades 1**:

  * Repositori d'origen: https://ftp.ncbi.nlm.nih.gov/geo/series/GSE140nnn/GSE140494/matrix/
  * Reanomenat com a: data_part_1.txt

- **Conjunt de dades 2**:

  * Repositori d'origen: https://ftp.ncbi.nlm.nih.gov/geo/series/GSE43nnn/GSE43365/matrix/
  * Reanomenat com a: data_part_2.txt
  
Ubicats dins la carpeta '/data/'
  
Ambdós conjunts de dades contenen una sèrie de caraterístiques descriptives de les pacients i els tumors de mama analitzats, entre elles, el **grau histològic** del tumor que és la variable classificadora que actua com a objectiu en la regressió. A més a més, contenen les **matrius d'expressions genètiques** que han estat extretes amb la tècnica de microarrays i serviran per a definir la importància en cada un dels graus histològics.

La **plataforma** tecnològica utilitzada per a l'extracció de les dades genètiques en els dos conjunts de dades pertany a l'empresa *Affymetrix Probe Set*. Aquesta serveix d'enllaç entre les sondes corresponents a les mostres d'un valor d'expressió i la informació genètica (nom del gen o conjunts de gens). 

La taula d'equivalències genètiques de la plataforma emprada en la tecnologia de microarrays es troba en la URL: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GPL570

S'ha anomenat 'GPL570-55999.txt' i s'ha ubicat dins la carpeta 'data/platform_microarrays'

## 1.1 Càrrega i processament conjunt de dades 1 (data_part_1)

A continuació es mostra tot el procés de càrrega, filtratge de variables i processament del conjunt de dades 1

```{r}

#### FILE 1 PROCESSMENT: Processat i captura dels atributs identificadors dels pacients, el grau histològic i informació addicional ####

### CÀRREGA DE DADES ###
# Ruta al fitxer de dades 1
file_path_1 <- paste0(ruta_input,"data_part_1.txt")

# Lectura de línies
lines_file_1 <- readLines(file_path_1)

cat("DATASET 1, PAS 1: Filtratge i captura de camps")
####### PAS 1: Filtratge #########
# Filtrem els camps que ens interessen en el fitxer.
# Id del pacient ve a !Sample_title
sample_title_1 <- grep("^!Sample_title", lines_file_1, value = TRUE)
# Capturem informació sobre el grau histològic del tumor en '!Sample_characteristics_ch1' (només el que contingui 'tumor_grade:')
sample_characteristics_1 <- grep("^!Sample_characteristics_ch1.*tumor grade:", lines_file_1, value = TRUE)
# 'geo_accession' coné un identificador únic (en aquest cas GSM, per tant corresponent a una mostra individual que indentifica l'expressió genètica de l'individu)
sample_geo_accession_1 <- grep("^!Sample_geo_accession", lines_file_1, value = TRUE)
# Es captura el tipus d'expressió genètica que es sempre RNA
sample_type_1 <- grep("^!Sample_type", lines_file_1, value = TRUE)
# Es captura el país de residència de la pacient en 'Sample_contact_country'
sample_country_1 <- grep("^!Sample_contact_country", lines_file_1, value = TRUE)
# En 'sample_source_name_ch1' es captura la font biològica d'origen de la mostra (tumor de mama, biòpsia de tumor de mama...etc) 
sample_name_1 <- grep("^!Sample_source_name_ch1", lines_file_1, value = TRUE)


cat("DATASET 1, PAS 2: Transformació de camps")
###### PAS 2: Transformació ######
# Separar els elements resultants pel delimitador "\t"
sample_title_split_1 <- strsplit(sample_title_1, "\t")[[1]]
sample_characteristics_split_1 <- strsplit(sample_characteristics_1, "\t")[[1]]
sample_geo_accession_split_1 <- strsplit(sample_geo_accession_1, "\t")[[1]]
sample_type_split_1 <- strsplit(sample_type_1, "\t")[[1]]
sample_country_split_1 <- strsplit(sample_country_1, "\t")[[1]]
sample_name_split_1 <- strsplit(sample_name_1, "\t")[[1]]

# Per a 'sample_characteristics_2' tenim dues columnes on apareix la característica 'tumor_grade' i són complementàries, és a dir,
# els índex de posicions on surt el 'tumor_grade' en la primera és on no surt a la segona i viceversa. Quan no informa del 'tumor_grade'
# en la primera, indica el 'cm_stage / er_status'. Quan no informa del 'tumor_grade' en la segona, indica el 'er_status / pr_status'. El que es farà és:

# De la primera charactersitics_ch1 ens quedem amb el 'tumor_grade' i on NO hi hagi un 'tumor_grade' posem un string buit.
sample_characteristics_1_1 <- sample_characteristics_1[1]
sample_characteristics_1_1_split_2 <- strsplit(sample_characteristics_1_1, "\t")[[1]]
# En la segona characteristics_ch1 es procedeix de la mateixa manera
sample_characteristics_1_2 <- sample_characteristics_1[2]
sample_characteristics_1_2_split_2 <- strsplit(sample_characteristics_1_2, "\t")[[1]]

# Eliminar el primer element corresponent al nom de la columna o del camp
sample_title_clean_1 <- sample_title_split_1[-1]
sample_characteristics_1_1_clean_2 <- sample_characteristics_1_1_split_2[-1]
sample_characteristics_1_2_clean_2 <- sample_characteristics_1_2_split_2[-1]
sample_geo_accession_clean_1 <- sample_geo_accession_split_1[-1]
sample_type_1 <- sample_type_split_1[-1]
sample_country_clean_1 <- sample_country_split_1[-1]
sample_name_clean_1 <- sample_name_split_1[-1]

# Eliminació de les cometes entre els elements
sample_title_clean_1 <- gsub("\"", "", sample_title_clean_1)
sample_characteristics_1_1_clean_2 <- gsub("\"", "", sample_characteristics_1_1_clean_2)
sample_characteristics_1_2_clean_2 <- gsub("\"", "", sample_characteristics_1_2_clean_2)
sample_geo_accession_clean_1 <- gsub("\"", "", sample_geo_accession_clean_1)
sample_type_clean_1 <- gsub("\"", "", sample_type_1)
sample_country_clean_1 <- gsub("\"", "", sample_country_clean_1)
sample_name_clean_1 <- gsub("\"", "", sample_name_clean_1)

# En el cas dels graus histològics, capturem només el que es descriu en 'tumor_grade:'. Si no es conté
# la cadena 'tumor_grade:', aleshores el valor en aquesta posició es deixa a buit ja que no és el grau histològic
sample_characteristics_1_1_clean_2 <- ifelse(!grepl("tumor grade:", sample_characteristics_1_1_clean_2), "", sample_characteristics_1_1_clean_2)
sample_characteristics_1_2_clean_2 <- ifelse(!grepl("tumor grade:", sample_characteristics_1_2_clean_2), "", sample_characteristics_1_2_clean_2)
# Finalment, unificarem els resultats fent que en les posicions buides quedin els 'tumor_grade' complementaris de les 2 characteristics
sample_characteristics_1_clean_final <- paste0(sample_characteristics_1_1_clean_2, sample_characteristics_1_2_clean_2)
# Extraiem l'últim caràcter i el convertim en número. Si es troba '' es substitueix per NA 
tumor_grades_1 <- as.numeric(sub(".*grade: ", "", sample_characteristics_1_clean_final))

cat("DATASET 1, PAS 3: Generació del dataset parcial sense la informació de l'expressió genètica")
# Generem el dataset1 parcial sense la informació de l'expressió genètica del pacient amb les variables escollides anteriorment. El dataframe tindrà
# - TITLE (identificador del pacient amb tumor de mama, obligatori)
# - GEO_ACCESSION (identificador de la mostra del pacient, obligatori)
# - COUNTRY (país de residència del pacient, opcional)
# - TYPE (tipus estrucutral de la mostra: ARN, obligatori)
# - NAME (font biològica d'origen de la mostra, obligatori)
# - HISTOLOGICAL_GRADE (grau histològic del tumor que serà la variable objectiu obligatòria i podrà tenir tres valors: 1, 2 o 3)
dataset1_parcial <- data.frame(
  TITLE = sample_title_clean_1,
  GEO_ACCESSION = sample_geo_accession_clean_1,
  COUNTRY = sample_country_clean_1,
  TYPE = sample_type_clean_1,
  NAME = sample_name_clean_1,
  HISTOLOGICAL_GRADE = tumor_grades_1
)

head(dataset1_parcial)
tail(dataset1_parcial)

```

Amb tot això, ja es té una part del conjunt de dades procedent de la primera font d'origen filtrat i processat amb la següent informació:

 - TITLE (identificador del pacient amb tumor de mama, obligatori)
 - GEO_ACCESSION (identificador de la mostra del pacient, obligatori)
 - COUNTRY (país de residència del pacient, opcional)
 - TYPE (tipus estrucutral de la mostra: per exemple ARN, obligatori)
 - NAME (font biològica d'origen de la mostra, obligatori)
 - HISTOLOGICAL_GRADE (grau histològic del tumor que serà la variable objectiu obligatòria i podrà tenir tres valors: 1, 2 o 3)
 
Posteriorment s'obté, es **filtra i es processa la matriu d'expressions genètiques extreta per microarrays**. En ella, cada fila representa un gen o conjunts de gens i cada columna una mostra de la pacient referida a través del GEO_ACCESSION.

```{r}
cat("DATASET 1, PAS 4: Captura i càrrega de la matriu d'expressions genètiques extreta per microarrays")
### MATRIU DE DADES DE L'EXPRESSIÓ GENÈTICA ###
# En aquest fitxer els ID_REF apunten a la taula de la plataforma 'GPL570-55999'

# Ens situem en la zona de la matriu de dades, que s'inicia en '!series_matrix_table_begin' i conclou en 'series_matrix_table_end'
inici_matriu_1 <- grep("!series_matrix_table_begin", lines_file_1)
fi_matriu_1 <- grep("!series_matrix_table_end", lines_file_1)

# Capturem el contingut entre inici i fi
# Extraiem la part desitjada
matriu_expressio_genetica_1 <- lines_file_1[(inici_matriu_1 + 1):(fi_matriu_1 - 1)]

# Ho convertim a un dataframe on l'espai '\t' serà el delimitador de columna
matriu_expressio_genetica_1 <- read.table(text = matriu_expressio_genetica_1, header = TRUE, sep = "\t", quote = "\"")

# Mostrem estadístiques bàsiques
cat("** DADES :** \n")
head(matriu_expressio_genetica_1[1:10],n=5)
tail(matriu_expressio_genetica_1[1:10],n=5)
cat("** ESTRUCTURA: **\n")
str(matriu_expressio_genetica_1)
cat("** ESTADÍSTIQUES BÀSIQUES: **\n")
summary(matriu_expressio_genetica_1)

# Obtenir dimensions de la matriu
dimensions <- dim(matriu_expressio_genetica_1)
# Mostrar el nombre de files y columnas
cat("La matriu d'expressions genètiques té ", dimensions[1], "files i", dimensions[2], "columnes.\n")
```

## 1.2 Normalització de valors conjunt de dades 1

Per tal de tenir totes les dades (les  d'aquest conjunt de dades i les del segon) en la mateixa escala, es sotmet la matriu d'expressions genètiques a un **procés de normalització** que deixa tots els seus valors entre **l'interval 0-1**. 

Es fa servir la funció genèrica creada en el punt 0: normalize_matrix

```{r}
cat("DATASET 1, PAS 5: Normalització de dades")
## Per tal de tenir tots els valors en la mateixa escala a l'hora d'unir els dos conjunts de dades, realitzem una normalització de valors de la matriu entre 0 i 1
## Cridem la funció creada en 'general_functions' anomenada 'normalize_matrix'
# Passem els valors numèrics (no s'inclou la primera columna dels identificadors)
matriu_expressio_genetica_1_norm <- normalize_matrix(matriu_expressio_genetica_1[, 2:ncol(matriu_expressio_genetica_1)])

# Reafegim la columna original dels identificadors
matriu_expressio_genetica_1_norm <- cbind(matriu_expressio_genetica_1[, 1, drop = FALSE], matriu_expressio_genetica_1_norm)

cat("La matriu d'expressions genètiques ja ha estat normalitzada amb valors entre 0 i 1:\n")
head(matriu_expressio_genetica_1_norm[1:10],n=5)
tail(matriu_expressio_genetica_1_norm[1:10],n=5)
```

## 1.3 Càrrega i processament conjunt de dades 2 (data_part_2)

A continuació es mostra tot el procés de càrrega, filtratge de variables i processament del conjunt de dades 2

```{r}

#### FILE 2 PROCESSMENT ####

### CÀRREGA DADES ###
# Ruta al fitxer origen
file_path_2 <- paste0(ruta_input,"data_part_2.txt")

# Lectura de línies
lines_file_2 <- readLines(file_path_2)

cat("DATASET 2, PAS 1: Filtratge i captura de camps")
####### FILTERING #########
# Filtrem els camps que ens interessen en cada fitxer.
# Id del pacient ve a !Sample_title 
sample_title_2 <- grep("^!Sample_title", lines_file_2, value = TRUE)
# Capturem informació sobre el grau histològic del tumor en '!Sample_characteristics_ch1' (només el que contingui 'grade histo:')
sample_characteristics_2 <- grep("^!Sample_characteristics_ch1.*grade histo:", lines_file_2, value = TRUE)
# 'geo_accession' coné un identificador únic (en aquest cas GSM, per tant corresponent a una mostra individual que indentifica l'expressió genètica de l'individu)
sample_geo_accession_2 <- grep("^!Sample_geo_accession", lines_file_2, value = TRUE)
# Es captura el tipus d'expressió genètica que es sempre RNA
sample_type_2 <- grep("^!Sample_type", lines_file_2, value = TRUE)
# Es captura el país de residència de la pacient en 'Sample_contact_country'
sample_country_2 <- grep("^!Sample_contact_country", lines_file_2, value = TRUE)
# En 'sample_source_name_ch1' es captura la font biològica d'origen de la mostra (tumor de mama, biòpsia de tumor de mama...etc) 
sample_name_2 <- grep("^!Sample_source_name_ch1", lines_file_2, value = TRUE)


cat("DATASET 2, PAS 2: Transformació de camps")
###### TRANSFORMATION ######
# Separar els elements pel delimitador "\t"
sample_title_split_2 <- strsplit(sample_title_2, "\t")[[1]]
sample_characteristics_split_2 <- strsplit(sample_characteristics_2, "\t")[[1]]
sample_geo_accession_split_2 <- strsplit(sample_geo_accession_2, "\t")[[1]]
sample_type_split_2 <- strsplit(sample_type_2, "\t")[[1]]
sample_country_split_2 <- strsplit(sample_country_2, "\t")[[1]]
sample_name_split_2 <- strsplit(sample_name_2, "\t")[[1]]

# Eliminar el primer element corresponent al nom de la columna o del camp
sample_title_clean_2 <- sample_title_split_2[-1]
sample_characteristics_clean_2 <- sample_characteristics_split_2[-1]
sample_geo_accession_clean_2 <- sample_geo_accession_split_2[-1]
sample_type_clean_2 <- sample_type_split_2[-1]
sample_country_clean_2 <- sample_country_split_2[-1]
sample_name_clean_2 <- sample_name_split_2[-1]

# Eliminació de les cometes entre els elements
sample_title_clean_2 <- gsub("\"", "", sample_title_clean_2)
sample_characteristics_clean_2 <- gsub("\"", "", sample_characteristics_clean_2)
sample_geo_accession_clean_2 <- gsub("\"", "", sample_geo_accession_clean_2)
sample_type_clean_2 <- gsub("\"", "", sample_type_clean_2)
sample_country_clean_2 <- gsub("\"", "", sample_country_clean_2)
sample_name_clean_2 <- gsub("\"", "", sample_name_clean_2)

# En el cas dels graus histològics, capturem només l'element numèric que ens interessa que es troba després de 'grade histo:'
tumor_grades_2 <- as.numeric(sub(".*histo: ", "", sample_characteristics_clean_2))

cat("DATASET 2, PAS 3: Generació del dataset parcial sense la informació de l'expressió genètica")
# Generem el dataset2 parcial sense la informació de l'expressió genètica del pacient amb les variables escollides anteriorment. El dataframe tindrà
# - TITLE (identificador del pacient amb tumor de mama, obligatori)
# - GEO_ACCESSION (identificador de la mostra del pacient, obligatori)
# - COUNTRY (país de residència del pacient, opcional)
# - TYPE (tipus estrucutral de la mostra: ARN, obligatori)
# - NAME (font biològica d'origen de la mostra, obligatori)
# - HISTOLOGICAL_GRADE (grau histològic del tumor que serà la variable objectiu obligatòria i podrà tenir tres valors: 1, 2 o 3)
dataset2_parcial <- data.frame(
  TITLE = sample_title_clean_2,
  GEO_ACCESSION = sample_geo_accession_clean_2,
  COUNTRY = sample_country_clean_2,
  TYPE = sample_type_clean_2,
  NAME = sample_name_clean_2,
  HISTOLOGICAL_GRADE = tumor_grades_2
)

head(dataset2_parcial)
tail(dataset2_parcial)

```

Anàlogament al conjunt de dades 1 de la secció anterior, ja es té una part del conjunt de dades filtrat i processat amb la següent informació:

 - TITLE (identificador del pacient amb tumor de mama, obligatori)
 - GEO_ACCESSION (identificador de la mostra del pacient, obligatori)
 - COUNTRY (país de residència del pacient, opcional)
 - TYPE (tipus estrucutral de la mostra: ARN, obligatori)
 - NAME (font biològica d'origen de la mostra, obligatori)
 - HISTOLOGICAL_GRADE (grau histològic del tumor que serà la variable objectiu obligatòria i podrà tenir tres valors: 1, 2 o 3)

El següent pas és, per tant,**l'obtenció i processament de la matriu d'expressions genètiques** extreta per microarrays aplicant els mateixos criteris.


```{r}
cat("DATASET 2, PAS 4: Captura i càrrega de la matriu d'expressions genètiques extreta per microarrays")
### MATRIU DE DADES DE L'EXPRESSIÓ GENÈTICA ###
# En aquest fitxer els ID_REF apunten a la taula de la plataforma 'GPL570-55999'

# Ens situem en la zona de la matriu de dades, que s'inicia en '!series_matrix_table_begin' i conclou en 'series_matrix_table_end'
inici_matriu_2 <- grep("!series_matrix_table_begin", lines_file_2)
fi_matriu_2 <- grep("!series_matrix_table_end", lines_file_2)

# Capturem el contingut entre inici i fi
# Extraiem la part desitjada
matriu_expressio_genetica_2 <- lines_file_2[(inici_matriu_2 + 1):(fi_matriu_2 - 1)]

# Ho convertim a un dataframe on l'espai '\t' serà el delimitador de columna
matriu_expressio_genetica_2 <- read.table(text = matriu_expressio_genetica_2, header = TRUE, sep = "\t", quote = "\"")

# Mostrem estadístiques bàsiques
cat("** DADES : **\n")
head(matriu_expressio_genetica_2[1:10],n=5)
tail(matriu_expressio_genetica_2[1:10],n=5)
cat("** ESTRUCTURA:**\n ")
str(matriu_expressio_genetica_2)
cat("** ESTADÍSTIQUES BÀSIQUES: **\n")
summary(matriu_expressio_genetica_2)

# Obtenir dimensions de la matriu
dimensions <- dim(matriu_expressio_genetica_2)
# Mostrar el nombre de files y columnas
cat("La matriu d'expressions genètiques té ", dimensions[1], "files i", dimensions[2], "columnes.\n")
```

## 1.4 Normalització de valors conjunt de dades 2

Finalment, tal i com s'ha fet també en el conjunt de dades anterior, s'aplica una **normalització dels valors genètics (entre 0 i 1)** ja que en els dos conjunts de dades estan en escales amb intervals completament diferents.


```{r}
cat("DATASET 2, PAS 5: Normalització de dades")
## Per tal de tenir tots els valors en la mateixa escala a l'hora d'unir els dos conjunts de dades, realitzem una normalització de valors de la matriu entre 0 i 1
## Cridem la funció creada en 'general_functions' anomenada 'normalize_matrix'
# Passem els valors numèrics (no s'inclou la primera columna dels identificadors)
matriu_expressio_genetica_2_norm <- normalize_matrix(matriu_expressio_genetica_2[, 2:ncol(matriu_expressio_genetica_2)])

# Reafegim la columna original dels identificadors
matriu_expressio_genetica_2_norm <- cbind(matriu_expressio_genetica_2[, 1, drop = FALSE], matriu_expressio_genetica_2_norm)
cat("La matriu d'expressions genètiques ja ha estat normalitzada amb valors entre 0 i 1:\n")
head(matriu_expressio_genetica_2_norm[1:10],n=5)
tail(matriu_expressio_genetica_2_norm[1:10],n=5)
```

## 1.5 Obtenció d'informació de gens de la matriu a partir de la plataforma i unió dels conjunts de dades

Un cop generades i normalitzades les matrius d'expressions genètiques d'ambdós conjunts de dades, cal **accedir a la taula de la plataforma** corresponent de l'extracció per microarrays i obtenir la **informació sobre els símbols dels gens** que necessitem.

Les plataformes dels microarrays pertanyen a l'empresa Affymetrix. El nom dels gens el conté la columna 'GENE_SYMBOL'i l'element relacionant entre les matrius d'expressió és 'ID_REF.'

Per tant, s'afegeix a les dues matrius **la unió amb la nova columna informativa** sobre el símbols dels gens de cada mostra a partir de la taula de la plataforma.

```{r}
# Ruta a la taula de la plataforma
file_to_platform_affymetrix <- paste0(ruta_input,"platform_microarrays/")
file_platofrm_name <- "GPL570-55999.txt"

cat("PROCESSAT PAS 1: Càrrega, processat i unió de les dades de la matriu d'expressió genètica obtinguda del conjunt de dades amb la informació proporcionada per la taula de la plataforma")

# 1. Cridem la funció 'process_platform_table' de 'general_functions' que realitza tota la carrega, processat i unió de les dades
# de la matriu d'expressió genètica obtinguda del conjunt de dades amb la informació proporcionada per la taula de la plataforma (GENE_SYMBOL)
# El nexe d'unió és el ID_REF
# Per a la matriu del conjunt de dades 1
matriu_expressio_genetica_1_final <- process_platform_table(file_to_platform_affymetrix, file_platofrm_name, matriu_expressio_genetica_1_norm)
# Per a la matriu del conjunt de dades 2
matriu_expressio_genetica_2_final <- process_platform_table(file_to_platform_affymetrix, file_platofrm_name, matriu_expressio_genetica_2_norm)
```

Seguidament, cal **netejar i processar els resultats** de les matrius d'expressions genètiques unides amb la informació dels noms dels gens de la plataforma. Al realitzar aquesta unió ens trobem amb el següent:

  - 1) Files amb **ID_REF que no existeix a la taula de la plataforma** i, en conseqüència, no se'n pot extreure el nom del gen o conjunt de gens. En cas de trobar-se, aquestes files **s'eliminen** de la matriu ja que es consideren sondes de control d'experiment sense correspondència.
  
  - 2) Files que el seu **ID_REF apunta als mateixos símbols de gens** (GENE_SYMBOL igual) ja que es troba situat en diferents llocs. En aquest cas s'agrupen totes les files que tenen el mateix símbol de gen/s i com a valor d'expressió final s'assigna la seva **mitjana aritmètica**.


```{r}
cat("PROCESSAT PAS 2: Procés de neteja de les dades d'expressió genètica unides amb la informació de la plataforma que s'han obtingut en el pas anterior")

# 2. Cridem la funció 'merge_platform_with_gene_expression' que realitza el procés de neteja de les dades d'expressió genètica unides amb la
# informació de la plataforma que s'han obtingut en el pas anterior

# Per a la matriu unificada del conjunt de dades 1
cat("Matriu del conjunt de dades 1:")
matriu_expressio_genetica_1_final_proc <- process_merged_gene_expression(matriu_expressio_genetica_1_final)
# Per a la matriu unificada del conjunt de dades 2
cat("Matriu del conjunt de dades 2:")
matriu_expressio_genetica_2_final_proc <- process_merged_gene_expression(matriu_expressio_genetica_2_final)

# Visualizem els resultats
head(matriu_expressio_genetica_1_final_proc[1:10],n=5)
tail(matriu_expressio_genetica_1_final_proc[1:10],n=5) 

head(matriu_expressio_genetica_2_final_proc[1:10],n=5)
tail(matriu_expressio_genetica_2_final_proc[1:10],n=5)

# Obtenir dimensions de la matrius
dimensions_1 <- dim(matriu_expressio_genetica_1_final_proc)
# Calcular el número de mostres excloent la primera columna
num_mostres_1 <- dimensions_1[2] - 1  # Resta 1 per a excloure la columna GENE_SYMBOL
# Mostrar el nombre de files y columnas
cat("La matriu d'expressió genètica processada 1 té ", dimensions_1[1], "sondes genètiques i", num_mostres_1, "mostres\n")

dimensions_2 <- dim(matriu_expressio_genetica_2_final_proc)
# Calcular el número de mostres excloent la primera columna
num_mostres_2 <- dimensions_2[2] - 1  # Resta 1 per a excloure la columna GENE_SYMBOL
# Mostrar el nombre de files y columnas
cat("La matriu d'expressió genètica processada 2 té ", dimensions_2[1], "sondes genètiques i", num_mostres_2, "mostres\n")
```

Realitzat el pas anterior, **unifiquem les dues matrius** d'expressions genètiques dels dos conjunts de dades en una de sola a través del seu 'GENE_SYMBOL'.

```{r}
cat("PROCESSAT PAS 3: Unió de les matrius resultants en una de sola")

# Unim les dues matrius resultants de les expressions genètiques dels diferents conjunts de dades per a que quedi en una de sola
# El nexe d'unió serà GENE_SYMBOL

matriu_expressio_genetica_final_unificada <- merge(
  matriu_expressio_genetica_1_final_proc, 
  matriu_expressio_genetica_2_final_proc, 
  by = c("GENE_SYMBOL"), 
  all = TRUE
)

```

Elidim els 5 últims registres del conjunt de dades que no aporten cap tipus d'informació gènica (no es consideren símbols de gens vàlids) i visualitzem una mostra dels resultats:

```{r}
cat("PROCESSAT PAS 4: Neteja de dades")

n <- nrow(matriu_expressio_genetica_final_unificada)
matriu_expressio_genetica_final_unificada <- matriu_expressio_genetica_final_unificada[1:(n - 5), ]

# Visualizem els resultats
head(matriu_expressio_genetica_final_unificada[1:10], n=5)
tail(matriu_expressio_genetica_final_unificada[1:10], n=5) 

# Obtenir dimensions de la matrius
dimensions_finals <- dim(matriu_expressio_genetica_final_unificada)
# Calcular el número de mostres excloent la primera columna
num_mostres_finals <- dimensions_finals[2] - 1  # Resta 1 per a excloure la columna GENE_SYMBOL
# Mostrar el nombre de files y columnas
cat("La matriu d'expressió genètica processada 1 té ", dimensions_finals[1], "sondes genètiques i", num_mostres_finals, "mostres\n")
```

Finalment, **s'unifiquen també els dos conjunts de dades parcials** generats en les seccions 1.1 i 1.2 que contenien informació de les pacients, els tumors i els graus histològics d'aquests. D'aquesta manera es tenen els dos conjunts de dades unificats tant per la part informativa com per les matrius d'expressions genètiques.

```{r}
## UNIÓ DATASETS parcials sense informació genètica
cat("PROCESSAT PAS 5: Unió dels datasets 1 i 2 parcials (que no incluen informació genètica dels pacients")
dataset_final <- rbind(dataset1_parcial, dataset2_parcial)

head(dataset_final, n=5)
tail(dataset_final, n=5)
```


# 2. Selecció de característiques

Després de tot el procés de generació de la matriu d'expressions genètiques final unificada i normalitzada, cal sotmetre tot el conjunt de files amb informació genètica a un **procés de selecció per a que triï aquells gens o conjunt de gens que tenen més rellevància**. Aquest procés serà útil per reduir la dimensionalitat de les variables a analitzar pels posterors models de Machine-Learning i reduir soroll, costos temporals i computacionals

Com que encara no es disposa d'una variable objectiu, una manera de seleccionar les característiques (gens) més importants és a partir de la **desviació estàndard** de cada una de les files a partir dels valors de totes les mostres. 

La desviació estàndard és un bon **indicador de variabilitat** de les mostres: les files (gens) amb valors molt baixos de desviació estàndard denotaran una variabilitat molt baixa i per tant, la majoria dels seus valors seran similars i sense diferències significatives (propers a la mitjana aritmètica). El que ens interessa es veure quins gens són capaços de classificar i per tant, els que variïn poc no tindran aquesta capacitat ja que seran iguals per a tots els graus histològics. Pel contrari, els que tinguin valors més alts o més baixos són els que aportaran més informació.

```{r}
## SELECCIÓ I REDUCCIÓ DE CARACTERÍSTIQUES ##

cat("SELECCIÓ DE CARACTERÍSTIQUES a partir de la desviació estàndard\n")

# 1) En primer lloc, es calcularà la mitjana aritmètica dels valors de totes les mostres per a cada una de les files que representen els gens i es guardaran en una columna temporal 'Average'

cat("Càlculs desviació estàndard de cada fila:\n")
# Capturem en una variable la matriu d'expressió genètica sense la columna del GENE_SYMBOL
gene_expression_matrix <- matriu_expressio_genetica_final_unificada[, -1]
# Realitzem el càlcul de la mitjana aritmètica de cada fila a partir dels valors de les mostres i ho emmagatzemem en una columna temporal 'Average'
matriu_expressio_genetica_final_unificada$SD <- apply(gene_expression_matrix, 1, sd, na.rm = TRUE)
head(matriu_expressio_genetica_final_unificada[1:10], n=5)
tail(matriu_expressio_genetica_final_unificada[1:10], n=5)

# 2) Seguidament, s'estabilarà el llindar que servirà de filtre per determinar quines files (gens) tenen una rellevància suficientment significativa per ser tinguts en compte en el procés de Machine-Learning supervisat de regressió posterior i, pel contrari, quines d'elles poden ser eliminades degut als baixos valors de totes les seves mostres.

# Calculem la mitjana de totes les desviacions estàndard obtingudes per tenir una referència del promig general
total_sd_average <- mean(matriu_expressio_genetica_final_unificada$SD, na.rm = TRUE)
# Establim el llindar com la mitjana aritmètica global de les desviacions estàndard
llindar <- total_sd_average
cat("El llindar del filtrat és ", llindar, "\n")

cat("Aplicació de filtre: \n")
# 3) Finalment, apliquem el filtre a partir del llindar ontingut. D'aquesta manera, totes les files (gens) que tinguin una desviació estàndard superior o igual al llindar establert, es consideraran rellevants pels futurs models de ML. En canvi, totes aquelles que no hi arribin seran eliminades ja que significa que la majoria de valors en les seves mostres són similars i amb poca variabilitat i, en conseqüència, manquen de la suficient importància a l'hora de definir la variable objectiu.
matriu_expressio_genetica_final_unificada_filtrada <- matriu_expressio_genetica_final_unificada[matriu_expressio_genetica_final_unificada$SD >= total_sd_average,]

cat("Nombre de gens originalment:", nrow(matriu_expressio_genetica_final_unificada), "\n")
cat("Nombre de gens seleccionats:", nrow(matriu_expressio_genetica_final_unificada_filtrada), "\n")
cat("La matriu d'expressió genètica s'ha reduït de" ,nrow(matriu_expressio_genetica_final_unificada), " a " ,nrow(matriu_expressio_genetica_final_unificada_filtrada), " característiques.\n")

```


# 3. Generació i muntatge del dataset final

Un cop aplicada la selecció de característiques anterior, ens queda preparar el conjunt de dades per a que sigui compatible amb els models de machine-learning futurs. Per tant, cal realitzar les següents operacions:

  - 1) Transposició de la matriu d'expressions genètiques: El conjunt de dades final haurà de tenir les dades gèniques en columnes i no en files, és a dir, cada fila representarà la informació d'un pacient diferent, els valors de les seves mostres per a cada un dels gens o conjunt de gens filtrats i finalment, el grau histològic del tumor. Per tant, per tal de poder tenir les dades de forma que cada fila representi un pacient caldrà transposar la matriu final d'expressions genètiques i capgirar les files per les columnes (els gens ara seran columnes i les mostres dels pacients seran files).
  
  - 2) Unió de les dades de les expressions genètiques amb la informació dels pacients i el grau histològic del tumor. Això suposoarà la generació i muntatge del conjunt de dades supervisat final que podrà ser utilitzat en totes les seccions posteriors.

## 3.1 Operacions de transposició i unificació final

A continuació, realtizem tots els processos necessaris per arribar a la transposició de la matriu d'expressions genètiques del conjunt de dades final, tal com s'ha especificat en la secció anterior:

```{r}
cat("Transposició matriu d'expressions genètiques\n")
# Eliminem la columna temporal 'Average' necessària en el punt anterior
matriu_expressio_genetica_final_unificada_filtrada <- matriu_expressio_genetica_final_unificada_filtrada[, !names(matriu_expressio_genetica_final_unificada_filtrada) %in% "SD"]
# Canviar el nom de la columna GENE_SYMBOL i posar-los com a nomsn (identificadors) de columna GENE_SYMBOL
rownames(matriu_expressio_genetica_final_unificada_filtrada) <- matriu_expressio_genetica_final_unificada_filtrada$GENE_SYMBOL
# Eliminació de la columna 'GENE_SYMBOL' ja que ara hi haurà tantes columnes com diferents GENE_SYMBOLS únics hi hagi
matriu_expressio_genetica_final_unificada_filtrada <- matriu_expressio_genetica_final_unificada_filtrada[, -1]  
# Transpoció de la matriu per a que les files siguin mostres de pacients i les columnes siguin els gens o conjunts de gens
matriu_expressio_genetica_final_unificada_filtrada_t <- t(matriu_expressio_genetica_final_unificada_filtrada)
# Conversió a dataframe
matriu_expressio_genetica_final_unificada_filtrada_t <- as.data.frame(matriu_expressio_genetica_final_unificada_filtrada_t)
# Finalment, creem la columna 'GEO_ACCESSION' que es correspon amb l'identificador de les mostres dels pacients i hi traslladem els GEO_ACCESSION que es troben ara com a identificadors de les files
matriu_expressio_genetica_final_unificada_filtrada_t$GEO_ACCESSION <- rownames(matriu_expressio_genetica_final_unificada_filtrada_t)
```

Seguidament, es realitza el procés d'unificació final que comporta la generació i muntatge del conjunt de dades final definitiu i l'eliminació dels registres que tenen el camp corresponent al grau histològic desinformat:
```{r}
cat("Unió de les expressions genètiques amb la informació dels pacients i el grau histològic del tumor\n")
# 2) Unió de la matriu d'expressions genètiques unificada i transposada, amb el dataset que conté la informació dels pacients i els graus histològics dels pacients a partir
# del GEO_ACCESSION com a variable relacionant.
dataset_final_unificat <- merge(dataset_final, matriu_expressio_genetica_final_unificada_filtrada_t, by = "GEO_ACCESSION", all.x = TRUE)

# Eliminem els registres que no tenen la informació mínima obligatòria requerida: grau histològic
dataset_final_unificat <- dataset_final_unificat[!is.na(dataset_final_unificat$HISTOLOGICAL_GRADE), ]

head(dataset_final_unificat[1:10],n=5)
tail(dataset_final_unificat[1:10],n=5)

# Obtenir dimensions finals del dataset
dimensions_finals_dataset <- dim(dataset_final_unificat)
# Mostrar el nombre de files y columnas
cat("El conjunt de dades final i definitiu té ", dimensions_finals_dataset[1], "files (pacients) i", dimensions_finals_dataset[2], "columnes\n")

# Finalment, escribim els resultats finals i definitius del conjunt de dades en un .csv
write_to_csv(dataset_final_unificat, ruta_output, "dataset_final.csv")
cat("Conjunt de dades final definitiu guardat i generat com a .csv a la ruta: ", paste0(ruta_output,"dataset_final.csv"))
```

## 3.2 Estadístiques bàsiques

Amb el conjunt de dades final generat, es mostren una sèrie d'estadístiques bàsiques per a mostrar el seu contingut, les dades i la seva estructura per ajudar en el seu anàlisi. 

A més a més, es mostren també estadístiques i gràfiques del repartiment dels registres (pacients) segons el grau histològic del tumor (variable objectiu). D'aquesta manera es podrà observar el balanceig de les dades per a les 3 classes possibles.
```{r}
dataset <- dataset_final_unificat

# Estadístiques descriptives i resums de columnes
# Per sintetitzar, excloem totes les columnes referents a gens o conjunt de gens
cat("Estadístiques \n")
summary(dataset[1:7])
cat("Estructura interna: \n")
str(dataset[1:7])

cat(" ESTADÍSTIQUES PER GRAU HISTOLÒGIC, VARIABLE OBJECTIU: \n")
# Pas 1: Comptar freqüències de cada categoria en la columna histologic_grade
counts <- table(dataset$HISTOLOGICAL_GRADE)
cat("Recompte de registres per a cada grau histològic: \n")
# Convertim els resultats a un data frame
counts_df <- as.data.frame(counts)
# Renombrament columnes
colnames(counts_df) <- c("GRAU HISTOLOGIC", "NUM. REGISTRES")
# Visualització taula
print(counts_df)

# Pas 2: Càlcul de percentatges
total_rows = nrow(dataset)
percentatges <- (counts / total_rows) * 100

cat("Percentatges de representació de registres per a cada grau histològic: \n")
# Convertim els resultats a un data frame
percentatges_df <- as.data.frame(percentatges)
# Renombrament columnes
colnames(percentatges_df) <- c("GRAU HISTOLOGIC", "% REGISTRES")
# Visualització taula
print(percentatges_df)

# Loop que recorre les files de la taula de percentatges
for(i in 1:nrow(percentatges_df)) {
  cat("Les pacients amb tumor de mama de grau histològic ", 
      percentatges_df$`GRAU HISTOLOGIC`[i], 
      " representen el ", 
      percentatges_df$`% REGISTRES`[i], 
      "% del total\n")
}

# Pas 3: Mostra d'histogrames segons variable objectiu: GRAU HISTOLOGIC
cat("Generació d'histograma que mostra les freqüències de pacients de tumors de mama en cada un dels tres graus histològics \n")
# Creació histograma de freqüencies de pacients segons els diferents graus histològics
hist_obj  <- hist(dataset$HISTOLOGICAL_GRADE, 
                  breaks = seq(0.5, 3.5, by = 1),  # Punts de tall
                  main = "Distribució de freqüències tumorals segons els Graus Histològics", 
                  xlab = "GRAU HISTOLÒGIC", 
                  ylab = "Freqüència", 
                  col = "red", 
                  border = "black", 
                  xaxt = "n")  # Evita los valors per defecte en eix X

# Inclusió de labels en l'eix X
axis(1, at = 1:3, labels = c("GRAU 1", "GRAU 2", "GRAU 3"))

# Inclusió informació percentatges en les barres
text(x = hist_obj$mids,  # Posicions X
     y = hist_obj$counts + 1,  
     labels = paste0(round(percentatges, 1), "%"),  # Format de percentatges
     cex = 1.2,  # Mida text
     col = "black")  # Color text

```
**ANÀLISI DE RESULTATS**:

Els casos de tumors de grau histològic 2 són els més freqüents en el nostre conjunt de dades destacant amb un 48% i 96 registres.El segueix de prop els tumors de grau histològic 3 amb un 40% (80 registres) i, en últim lloc, i amb una diferència considerablement pronunciada, tenim els casos de tumors de grau histològic 1 amb un 12% i 24 registres.

S'aprecia un **desbalanceig considerable del nombre de tumors de grau histològic 1** (12%) respecte als de grau 2 (48%) i 3 (40%). Aquest fet pot afectar a l'hora de definir amb precisió els gens o conjunts de gens més involucrats, ja que, a excepció de la resta, es posseeixen pocs casos per provar. Pel que respecta a la diferència entre el nombre d'elements de grau histològic 2 amb el d'elements de grau histològic 3, aquesta no és considerable ni molt significativa. Per tant, en aquests dos casos no hi ha un desbalanceig molt pronunciat i els resultats són bastant equitatius.El nombre de casos és més nombrós i, en conseqüència, els resultats poden ser més precisos i estar més ben ajustats.

Tot i els resultats, podem obviar el desbalanceig ja que els graus histològics que més interessa definir amb precisió són el 2 i el 3 que són més crítics que els de grau 1.


## 3.3 Resum de característiques

Finalment, es mostra una taula resum de les característiques principals del conjunt de dades final generat per tal de tenir clares les idees abans d'aplicar totes les tècniques de machine-learning supervisat i de regressió:
```{r}
tabla_info <- data.frame(
  "CARACTERÍSTICA" = c("TIPUS CONJUNT DE DADES", "TIPUS D'ALGORISME", "VARIABLE OBJECTIU", "TIPUS VARIABLE OBJECTIU", 
                       "VARIABLES INDEPENDENTS", "TIPUS VARIABLES INDEPENDENTS"),
  "DESCRIPCIÓ" = c("Supervisat", "Regressió", "HISTOLOGICAL_GRADE", 
                    "Quantitativa categòrica ordinal de 3 classes (1,2 i 3)", 
                    "Tot el conjunt de columnes que representen gens o conjunts de gens", 
                    "Quantitatives contínues amb valors normalitzats compresos entre 0 i 1")
)

# Mostrem la taula
#kable(tabla_info, col.names = c("CARACTERÍSTICA", "DESCRIPCIÓ"), align = "l")

tabla_info %>%
  kable(col.names = c("CARACTERÍSTICA", "DESCRIPCIÓ"), align = "l") %>%
  kable_styling(full_width = FALSE, position = "center", latex_options = "HOLD_position") %>%
  row_spec(0, bold = TRUE, color = "white", background = "#40E0D0") %>%  # Capçalera amb estil
  row_spec(1:nrow(tabla_info), hline_after = TRUE)  # Línies entre files
```


# 4. Tècniques de machine-learning supervisat de regressió

## 4.0 Preparació de dades

Com a pas previ a l'aplicació de les tècniques d'aprenentatge automàtic supervisat de regressió, cal **preprar les dades** per tal d'adaptar-les als requeriments exigits.

Per a poder treballar sobre el conjunt de dades supervisat que tenim, els models d'aprenentatge automàtic de regressió necessiten:

- **Variable objectiu**: Es correspon amb el grau histològic del tumor, que és sobre el que volem determinar els coeficients o índexs d'importàncies genètiques. Es tracta d'una variable numèrica ordinal de tres categories: 1, 2 i 3. Per tal de poder treballar bé sobre aquesta variable, i donat que el que ens interessa són tres resultats d'importàncies diferents per grau histològic (rellevàncies de gens o conjunts de gens en grau histològic 1, en el 2 i en el 3) el que es fa es **afegir tres columnes noves amb contingut binari que serveixin d'indicadors de pertinença del tumor de la pacient a un dels graus histològics**. És a dir, es tindran tres indicadors de pertinença per cada un dels graus histològics:

  - **is_grade_1**: Si el pacient té un tumor que està classificat amb grau histològic 1, el valor serà 1 i el dels altres indicadors, 0
  - **is_grade_2**: Si el pacient té un tumor que està classificat amb grau histològic 2, el valor serà 1 i el dels altres indicadors, 0
  - **is_grade_3**: Si el pacient té un tumor que està classificat amb grau histològic 3, el valor serà 1 i el dels altres indicadors, 0

  D'aquesta manera es podran aplicar els models d'aprenentatge automàtic per a cada un dels diferents graus histològics com a variable objectiu.    Aquesta, serà de tipus binari (on l'1 indica la pertinença i el 0 la no pertinença).

- **Variables independents (X) **: Conjunt de columnes informatives de les expressions genètiques de les pacients amb tumor de mama. Aquestes característiques es corresponen a les que hi ha a partir de la columna 7 en amunt (les que tenen un nom de gen o conjunt de gens). Els seus valors estan escalats entre 0 i 1 i són quantitatius continus.

```{r}
# Variable objectiu--> grau histològic (categòrica ordinal)
# Variables independents --> conjunt de 10.600 columnes referents a gens (valors continus normalitzats entre 0 i 1)

# Crear variables indicadores binàries per a cada registre sobre la seva pertinença a un grau histològic concret.
# D'aquesta manera es podran aplicar els algorismes de machine-learning de forma independent per 
# a cada una de les possibles categories de la variable objectiu (pertinença a grau 1, grau 2 o grau 3)
dataset$is_grade_1 <- ifelse(dataset$HISTOLOGICAL_GRADE == 1, 1, 0)
dataset$is_grade_2 <- ifelse(dataset$HISTOLOGICAL_GRADE == 2, 1, 0)
dataset$is_grade_3 <- ifelse(dataset$HISTOLOGICAL_GRADE == 3, 1, 0)

# Capturem les variables independents que són les corresponents als gens o conjunts de gens. Aquestes van de la columna 7
# a la N (10647) però n'hem d'excloure les 3 últimes variables temporals afegides en el pas anterior d'indicadors de grau específic.
# Ho convertim en matriu per a que sigui compatible amb els algorismes.

X <- as.matrix(dataset[, 7:(ncol(dataset) - 3)])
```

Per les característiques del conjunt de dades que tenim, l'objectiu que es persegueix i la quantitat immensa de variables independents que es posseeix, les tècniques d'aprenentatge automàtic supervisat de regressió que més s'adequen són:

- Tècniques basades en arbres de decisió i/o descens del gradient: **Random Forest, XGBoost o LightGBM**
- Tècniques basades en regularitzacions: **Ridge Regression, Lasso Regression o Elastic Net**


## 4.1 Tècniques basades en arbres de decisió i/o descens del gradient

### 4.1.1 Random Forest

### 4.1.2 XGBoost

**DEFINICIÓ**: 

XGBoost són les sigles de "Extreme Gradient Boosting". Es tracta d'un algorisme d'aprenentatge automàtic que permet manegar grans quantitats de conjunts de dades i té una elevada capacitat per a obtenir un bon rendiment en tasques de classificació i **regressió** sobre conjunts de dades **supervisats**. Porta integrat el processament en paral·lel.

Està basat en un **conjunt d'arbres de decisió potenciats per gradients**. Els arbres de decisió es creen seqüencialment i les variables independents s'incorporen en ells a través de pesos. Utilitza l'algorisme d'augment de gradient on cada predictor corregeix el seu predecessor.

**AVANTATGES**

- **Rendiment**: Té una producció de resultats d'alta qualitat en diverses tasques.
- **Escalabilitat**: És adequat per a grans conjunts de dades ja que el seu disseny el dota d'eficiència i escalabilitat en el seu entrenament.
- **Personalització**: Conté un ampli ventall d'hiperparàmetres que es poden ajustar per optimitzar els resultats
- Té suport integrat per a **manegar valors faltants** (resistent a dades que contenen valors buits o nuls)
- Permet obtenir les **importàncies de les característiques** que és, en gran mesura, l'objectiu que tenim per a cada valor del grau histològic.

**INCONVENINENTS**

- **Elevada complexitat computacional** derivada en un ús intensiu dels recursos computacionals especialment en l'entrenament de grans quantitats de dades.
- Propensió al **sobreentrenament** o sobreajustament si hi ha un conjunt de dades petit
- **Dificultat en l'ajustament dels seus hiperparàmetres** ja que el seu conjunt d'hiperparàmetres és molt ampli i pot resultat molt costós temporalment trobar-ne els òptims.
- **Elevat consum de memòria** si es treballa amb grans conjunts de dades.

**CERCA HIPERPARÈMTRES**

XGBoost té un gran conjunt d'hiperparàmetres que es poden ajustar i combinar de diferents maneres per tal de trobar el resultat òptim. El resultat òptim serà el que **maximitzi l'àrea sota la corba AUC** que és una mètrica de rendiment indicadora de la idoneïtat del nostre model. Per tant, el primer pas abans d'aplicar el model sobre el conjunt de dades, serà la cerca dels valors concrets combinats d'hiperparàmetres que donen més bon resultat en entrenar el model.

Els hiperparàmetres més rellevants en XGBoost són els següents:
- **max_depth**: Profunditat màxima dels arbres de decisió utilitzats en l'entrenament. Una profunditat elevada pot retornar millors resultats però a la vegada pot ser pronpensa a provocar sobreentrenament.
- **eta**: Taxa d'aprenentatge del model. Com més gran és el seu valor, el cost temporal i computacional es redueix ja que arriba abans a un "millor model". Pel contrari, per a valors petits es tardarà més en arribar a aquest millor model i el cost temporal i computacional serà més elevat.  
- **subsample**: Percentatge de dades (files) utilitzades per l'arbre en cada iteració
- **colsample_bytree**: Proporció de submostres de columnes al construir cada arbre
- **objective**: Tipus de tasca de classificació que es realitzarà, en el nostre cas, serà de tipus binària pels indicadors de pertinença a un grau histològic determinat.

Tenim també el paràmetre:
- **nrounds**: Nombre d'iteracions a realitzar abans d'acabar amb el procés de cerca. A més iteracions, més bons solen ser els resultats però també incrementa el cost temporal.

Com que el nombre d'iteracions no és eficient ni recomanable incloure'l dins el grid dels hiperparàmetres ja que funciona com un paràmetre independent a part, el que es realitzarà per a trobar el millor nombre de rondes és utilitzar la funció 'early_stopping'. Early_stopping és una tècnica que interromp el procés d'entrenament quan passades 'n' rondes consecutives ja no existeixen millores significatives en els resultats. En aquest cas, assignarem inicialment un nombre d'iteracions molt elevat (1000) i indicarem que s'apliqui early_stopping quan hi hagi 10 rondes seguides sense millores significatives. 

A continuació creem la funció que s'encarregarà de la cerca dels hiperparàmetres òptims en l'algorisme XGBoost i maximitzarà la mètrica de rendiment AUC:

```{r}
# Funció genèrica per a trobar els hiperpàrmatres òptims (aquells que maximitzen ) emprant la validació creuada
# i la graella d'opcions de param_grid
# Paràmetres:
# - X :conjunt de variables independents)
# - y :variable objectiu binària: is_grade_n)
# - param_grid: matriu inicial de possibles hiperparàmetres amb possibles valors
hyperparams_xgboost_search <- function(X, y, param_grid) {
  cat("Cerca d'hiperparàmetres òptims: \n")
  
  # Inicialitzar les variables per guardar el millor AUC i els seus hiperparàmetres
  best_auc <- -Inf
  best_params <- NULL
  best_nrounds <- NULL
  
  # Barra de progrés per a tenir una noció del temps
  pb <- progress_bar$new(
    format = "Avaluant hiperparàmetres :current/:total (:percent) Temps restant: \n",
    total = nrow(param_grid),
    clear = FALSE,
    width = 60
  )
  
  # Número màxim de rondes (es fixa alt) i early stopping
  max_nrounds <- 1000
  early_stopping_rounds <- 10
  
  # Bucle sobre la graella
  for (i in 1:nrow(param_grid)) {
    
    # Actualitzar la barra de progrés
    pb$tick()
    
    params <- list(
      objective = "binary:logistic",
      max_depth = param_grid$max_depth[i],
      eta = param_grid$eta[i],
      subsample = param_grid$subsample[i],
      colsample_bytree = param_grid$colsample_bytree[i]
    )
    
    # Imprimir els hiperparàmetres actuals
    cat("\n Avaluant hiperparàmetres en XGBoost ", y ," : ", 
        paste(names(params), unlist(params), sep = "=", collapse = ", "), "\n")
    
    # Validació creuada emprant xgb.cv amb early stopping
    cv_results <- xgb.cv(
      params = params,
      data = xgb.DMatrix(X, label = dataset[[y]]),
      nrounds = max_nrounds,
      nfold = 3,
      metrics = "auc", # corba error
      verbose = 0,
      early_stopping_rounds = early_stopping_rounds
    )

    # Obtenir el millor AUC per aquests hiperparàmetres
    current_auc <- max(cv_results$evaluation_log$test_auc_mean)
    
    # Si el AUC actual és millor que el millor fins ara, en el quedem. Així capturem el que maximitza best_auc
    if (current_auc > best_auc) {
      best_auc <- current_auc
      best_params <- params
      best_nrounds <- cv_results$best_iteration # afegim la iteració òptima trobada
    }
  }
  
  # Retornar els millors hiperparàmetres
  return(list(best_params = best_params, best_nrounds = best_nrounds, best_auc = best_auc))
}
```

Definim els possibles valors dels hiperparàmetres llistats, cridem la funció de cerca per a cada un dels graus histològics i observem quina ha estat la combinació de valors òptima dels hiperparàmetres que maximitza la mètrica AUC per a cada un d'ells:

```{r}
# Definim el grid de possibilitats d'hiperparàmetres per a cercar els òptims
param_grid_xgboost <- expand.grid(
  max_depth = c(3, 6, 9),
  eta = c(0.01, 0.1, 0.3), # taxa aprenentatge
  subsample = c(0.6, 0.8, 1), # mostres de l'arbre en cada iteració
  colsample_bytree = c(0.5, 0.7, 1), # columnes per entrenar arbres en cada iteració
  objective = "binary:logistic"  # Classificació binària (is_grade)
)

# Cridar a la funció per a cada un dels graus histològics
best_hyperparams_xgboost_grade_1 <- hyperparams_xgboost_search(X,"is_grade_1",param_grid_xgboost)
best_hyperparams_xgboost_grade_2 <- hyperparams_xgboost_search(X,"is_grade_2",param_grid_xgboost)
best_hyperparams_xgboost_grade_3 <- hyperparams_xgboost_search(X,"is_grade_3",param_grid_xgboost)

# Mostra els millors hiperparàmetres per a cada grau histològic
# Mostra els millors hiperparàmetres per a cada grau histològic
cat("Els millors hiperparàmetres trobats per al grau histològic 1 són:",
    paste(names(best_hyperparams_xgboost_grade_1$best_params), "=", unlist(best_hyperparams_xgboost_grade_1$best_params), collapse = ", "),
    ", amb nrounds =", best_hyperparams_xgboost_grade_1$best_nrounds, "\n")

cat("Els millors hiperparàmetres trobats per al grau histològic 2 són:",
    paste(names(best_hyperparams_xgboost_grade_2$best_params), "=", unlist(best_hyperparams_xgboost_grade_2$best_params), collapse = ", "),
    ", amb nrounds =", best_hyperparams_xgboost_grade_2$best_nrounds, "\n")

cat("Els millors hiperparàmetres trobats per al grau histològic 3 són:",
    paste(names(best_hyperparams_xgboost_grade_3$best_params), "=", unlist(best_hyperparams_xgboost_grade_3$best_params), collapse = ", "),
    ", amb nrounds =", best_hyperparams_xgboost_grade_3$best_nrounds, "\n")
```

**CÀLCUL IMPORTÀNCIES**

Un cop obtinguts els hiperparàmetres òptims, s'aplica la funció que permetrà obtenir el grau de rellevància dels diferents gens o conjunts de gens sobre cada categoria diferent del grau histològic. 

Per a poder procedir, caldrà realitzar un entrenament de l'algorisme XGBoost sobre tot el conjunt de dades que conformen les variables independents amb els valors òptims dels hiperparàmetres. No es divideix el conjunt de dades en subconjunts d'entrenament, validació i proves ja que el que ens interessa no és una classificació o predicció, sinó només calcular les importàncies de cada un dels gens o conjunts de gens (variables independents) en relació a la seva pertinença a un determinat grau histològic (variable objectiu).

```{r}
# Funció genèrica per obtenir la rellevància dels diferents gens o conjunts de gens a partir de cada grau histològic diferent i el conjunt d'hiperparàmetres òptims trobats amb la cross validation Search
# La variable objectiu ve marcada pel paràmetre indicador de grau i el retorn es el conjunt de resultats d'importàncies 
# per al grau concret.
xgboost_importance_by_grade <- function(X, histological_grade, best_params, best_nrounds) {
  
  cat("Cerca d'importàncies ",histological_grade, " \n")
  
  # L'algorisme requereix d'una matriu en format DMatrix
  # Volem saber la importància de cada gen respecte cada tipus de variable objectiu, per tant, no caldrà subdidir entre train i test
  # ja que no es volen realitzar prediccions de classificació. Tot el conjunt 'X' serà d'entrenament.
  dtrain <- xgb.DMatrix(data = X, label = dataset[[histological_grade]])
  
  # Entrenem model amb la matriu i els paràmetres
  model_final <- xgb.train(params = best_params, data = dtrain, nrounds = best_nrounds)
  
  # Obtenir i retornar la importància de les característiques 
  importance <- xgb.importance(model = model_final)
  
  return(importance)
  
}
```

Crida de la funció de càlcul d'importàncies genètiques per a cada un dels graus histològics:

```{r}
# A partir de la funció definida anteriorment, obtenim les importàncies de les característiques (gens) 
# per a cada classe (grau histològic: 1, 2 i 3)
# importàncies GRAU HISTOLÒGIC 1
importance_xgboost_grade_1 <- xgboost_importance_by_grade(X,"is_grade_1", best_hyperparams_xgboost_grade_1$best_params, best_hyperparams_xgboost_grade_1$best_nrounds)
# importàncies GRAU HISTOLÒGIC 2
importance_xgboost_grade_2 <- xgboost_importance_by_grade(X,"is_grade_2", best_hyperparams_xgboost_grade_2$best_params, best_hyperparams_xgboost_grade_2$best_nrounds)
# importàncies GRAU HISTOLÒGIC 3
importance_xgboost_grade_3 <- xgboost_importance_by_grade(X,"is_grade_3", best_hyperparams_xgboost_grade_3$best_params, best_hyperparams_xgboost_grade_3$best_nrounds)
```

**RESULTATS**

Per a mostrar els resultats de les importàncies dels gens o conjunts de gens obtingudes sobre cada un dels tres graus histològics diferents s'estableix un rànking que ordena les característiques (gens o agrupacions de gens) de major a menor importància segons el valor en 'Gain'.

El valor del guany o 'Gain' és clau per a determinar la importància d'una característica

**CONCLUSIONS**


### 4.1.3 LightGBM

## 4.2 Tècniques basades en regularitzacions

### 4.2.1 Ridge Regression o L2

- cerca hiperparàmetres
- càlcul coeficients d'importàncies
- resultats
  - ranking
  - diagrames de barres horitzontals
- conclusions

### 4.2.2 Lasso Regression o L1

- cerca hiperparàmetres
- càlcul coeficients d'importàncies
- resultats
  - ranking
  - diagrames de barres horitzontals
- conclusions

### 4.2.3 Elastic Net

- cerca hiperparàmetres
- càlcul coeficients d'importàncies
- resultats
  - ranking
  - diagrames de barres horitzontals
- conclusions


# Conclusions


